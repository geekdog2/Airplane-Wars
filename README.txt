问题一：在头文件中调用图形库时发生问题#include<easyx.h>无法使用
解决：在easy官网下载库、查阅图形库说明文档查询
可使用函数initgraph（）   \\用来定义绘画窗口的长宽高。
这个函数用于初始化绘图窗口
在线手册地址： https://docs.easyx.cn


问题二：loadimage报错。
解决：应使用多字节字符集（一个字符串占用一个字节）。

问题三：调用指针函数时手动在栈上分配内存空间
Node* temp = (Node*)malloc(sizeof(Node));
解决：希望在运行时动态创建内存来存储数据，而不是在编译时确定固定的内存大小。
原因：栈上的内存空间是有限的，如果尝试分配大量的内存（例如大型数组），可能导致栈溢出。动态内存分配则允许使用堆上的更大的内存空间。精细地控制内存的生存期。处理可变数量的数据或未知数据量的情况非常有用。

问题四：temp->next = NULL;指针为什么指空？
解决：动态分配内存时，要把没赋值的指针指空，避免出现野指针。因为动态分配内存分配后不会给内存初始化。

问题五：使用尾插法构建插入单链表。

问题六：原图和掩码图（此部分知识为图形库。）https://docs.easyx.cn/zh-cn/intro（技术文档）
解决：使用easyx库，将掩码图和源码图叠加在一起，用与或操作处理。（透明贴图）应该使用png贴图。

问题七：将创建的角色加入while循环中后，图片不断闪烁。
解决：闪烁是由于从内存移到绘画窗口需要时间。解决方法是创建缓存区。（easy库提供双缓冲绘图。）
BeginBatchDraw(); //加入缓存区
while循环加在中间（循环内需加入FlushBatchDraw() ，其作用通常是强制刷新并执行已经积累的批量绘制操作，确保它们被立即应用到屏幕上）
EndBatchDraw();//在绘画窗口绘制

问题八：阻塞问题，只有用户按键盘敌机、子弹等才会移动
解决方案1：_kbhit()是一个检测函数,用于检测键盘是否输入。可以解决阻塞的问题。不然用户不按键盘其它函数(操作)不会动。（最后采用了第二种方法。在这里保留了方法1的代码，可以更换。）
//检测是否有键盘按下，有返回1，没有返回0
	if (_kbhit()) //_kbhit()是一个检测函数,用于解决阻塞的问题，不然用户不按键盘其它函数(操作)不会动
	{
	//左右两种方式
	//1,_getch() 阻塞函数，和scanf一样，如果没有输入，就会卡主程序，一直等待输入
		char key = _getch();
		switch (key)
		{
		case 'w':
		case 'W':
			player.y -= speed;//向上移动
			break;
		case 's':
		case 'S':
			player.y += speed;//向下移动
			break;
		case 'a':
		case 'A':
			player.x -= speed;//向左移动
			break;
		case 'd':
		case 'D':
			player.x += speed;//向右移动
			break;
解决方案2：使用Windows函数获取键盘输入,GetAsyncKeyState()函数是直接判断函数按键的是什么，这是一个非阻塞函数，非常丝滑，可以实现异步操作，例如让飞机斜着跑。（辅助使用了条件编译）

问题九：设置边界条件时，右边和下边界无效。
解决：在x，y轴加上固定数值。（因为飞机的原点坐标也在左上角）

问题十:敌机出现的先后问题。左上角粘住了一驾敌机不动。
解决：设计定时器，让每驾敌机产生时间不同。

2024.1.24（第一版）
版本问题：
左上角出现一驾无法消失的敌机
敌人中弹后不会立即消失，会卡几秒
子弹击中敌人后不会消失（穿透敌人）
己方飞机掉色


